
Spring 2018 - 46 questions with solutions
Spring 2020 - short summaries

# --------------------------------------------------------------
1 of 46: Getting Rich on Apple Stocks 

  stock_prices_yesterday = [10, 7, 5, 8, 11, 9]
  max_profit = get_max_profit(stock_prices_yesterday)
    # Returns 6 (buying for $5 and selling for $11)
    # No "shorting" - you must buy before you sell.
    # You may not buy and sell in the same time step.
    # If the stock value goes down all day, the best profit will be negative.
    # Do it in O(n) time and O(1) space!

Solution: Walk through the list and track:
      lowest price so far
      max profit so far

# --------------------------------------------------------------
2 of 46: Product of All Other Numbers 
  For each number in an array, find the product of all the other
  numbers. You can do it faster than you'd think!

Solution
  1. go forward and get the products of all the integers before each index, 
  2. go backwards and get the products of all the integers after each index,
  3. Multiply these numbers for each index.
  Complexity O(n) time, O(n) space

# --------------------------------------------------------------
3 of 46: Highest Product of 3 
  Find the highest possible product that you can get by
  multiplying any 3 numbers from an input array.

Solution:
  We use a greedy approach to solve the problem in one pass. 
  At each iteration we keep track of:
    highest_product_of_3
    highest_product_of_2
    highest
    lowest_product_of_2
    lowest

  When we reach the end, the highest_product_of_3 is our answer. 
  We maintain the others because they're necessary for keeping 
  the highest_product_of_3 up to date as we walk through the list. 
  At each iteration, the highest_product_of_3 is the highest of:

    the current highest_product_of_3
    current * highest_product_of_2
    current * lowest_product_of_2 
      (if current and lowest_product_of_2 are both low negative 
       numbers, this product is a high positive number).

  Complexity O(n) time and O(1) space

# --------------------------------------------------------------
4 of 46: Merging Meeting Times 
  Write a function for merging meeting times given everyone's
  schedules. It's an enterprise end-to-end scheduling solution.

Solution
  First, we sort our input list of meetings by start time so any 
  meetings that might need to be merged are now next to each other.

  Then we walk through our sorted meetings from left to right. 
  At each step, either:
   - We can merge the current meeting with the previous one, so we do.
   - We can't merge the current meeting with the previous one, 
     so we know the previous meeting can't be merged with any future 
     meetings and we throw the current meeting into merged_meetings.

  Complexity O(n lg n) time and O(n) space.

# --------------------------------------------------------------
5 of 46: Making Change 
  Write a function that, given:
    an amount of money
    a list of coin denominations
  computes the number of ways to make the amount of money 
  with coins of the available denominations.

Solution
  We use a bottom-up algorithm to populate a list
    ways_of_doing_n_cents 
  such that ways_of_doing_n_cents[k] is how many ways 
  we can get to k cents using our denominations.

  We start with the base case that there's one way 
  to create the amount zero, and progressively 
  add each of our denominations.

  The number of new ways we can make a higher_amount 
  when we account for a new coin is simply 
  ways_of_doing_n_cents[higher_amount - coin], 
  where we know that value already includes combinations 
  involving coin (because we went bottom-up, we know that
  smaller values have already been calculated).

  def change_possibilities_bottom_up(amount, denominations):
    ways_of_doing_n_cents = [0] * (amount + 1)
    ways_of_doing_n_cents[0] = 1

    for coin in denominations:
        for higher_amount in range(coin, amount + 1):
            higher_amount_remainder = higher_amount - coin
            ways_of_doing_n_cents[higher_amount] += (
                ways_of_doing_n_cents[higher_amount_remainder]
            )

    return ways_of_doing_n_cents[amount]

  Complexity O(n*m) time and O(n) additional space, where 
    n is the amount of money and 
    m is the number of potential denominations.

# --------------------------------------------------------------
6 of 46: Rectangular Love 
  Write a function to find the rectangular intersection of 
  two given rectangles.
  Rectangles are always "straight" and never "diagonal." 
  They are defined as dictionaries like this:
      my_rectangle = {
        'left_x'   : 1, 'bottom_y' : 1,
        'width'    : 6, 'height'   : 3,
      }
  Your output rectangle should use this format as well.

Solution
    We write a helper function find_range_overlap() that 
    can be used to find both the x overlap and the y overlap, 
    and we use it to build the rectangular overlap:

    Complexity O(1) time and O(1) space

# --------------------------------------------------------------
7 of 46: Temperature Tracker 
  Write code to continually track the max, min, mean, and mode 
  as new numbers are inserted into a tracker class.
    class TempTracker with these methods:
        insert()   - records a new temperature (int, 0...110)
        get_max()  - returns the highest temp we've seen so far (int)
        get_min()  - returns the lowest temp we've seen so far (int)
        get_mean() - returns the mean of all temps we've seen so far (float)
        get_mode() - returns the temperature which we encounted the most (int)

Solution:  trivial. Just update as we go.
  mean = running_sum / running_count

  Complexity O(1) for time for each method, and O(1) for space
  (we only use list of 110 temperatures)

# --------------------------------------------------------------
8 of 46 Balanced Binary Tree 
  Write a function to see if a binary tree is 'superbalanced' - a
  new tree property we just made up. A tree is "superbalanced" if 
  the difference between the depths of any two leaf nodes is <= 1.

Solution:
  We will use depth-first search to reach leaves faster.
  We define set of depths - and add to it as we reach leaves.
  We can traverse tree recursively.
  Or iteratively (put nodes in a queue as tuples (node,depth)).

# --------------------------------------------------------------
9 of 46: Binary Search Tree Checker 
  Write a function to check that a binary tree is a valid binary
  search tree. 
  Careful: checking a node against its parent isn't
           sufficient to prove...

INT_MAX =  int(4e9)
INT_MIN = -int(4e9)
 
class Node:
    def __init__(self, data):
        self.data = data 
        self.left = None
        self.right = None


def check_bst_valid(node, mini, maxi):
    if node is None:  # empty is True
        return True
    if node.data < mini or node.data > maxi:
        return False
    return ( 
        check_bst_valid(node.left, mini, node.data -1) 
        and 
        check_bst_valid(node.right, node.data+1, maxi) )

root = Node(4)
root.left = Node(2)
root.right = Node(5)
root.left.left = Node(1)
root.left.right = Node(3)
 
if (check_bst_valid(root, INT_MIN, INT_MAX)):
    print("Is BST")
else:
    print("Not a BST")

# --------------------------------------------------------------
10 of 46: 2nd Largest Item in a Binary Search Tree 
  Find the second largest element in a binary search tree. 

Solution:
  The largest element is the "rightmost".
  The 2nd largest may be:
    - the parent of the largest (if largest doesn't have left subtree)
    - the largest of the left subtree of the largest
         ( 5 )
        /     \
      (3)     (8)
     /  \     /  \
   (1)  (4) (7)  (12)
                 /
               (10)
               /  \
             (9)  (11)

  Complexity: O(h) time, where h is the height of the tree.
  This is O(lg(n)) for balanced tree, or O(n) for unbalanced.
  Space complexity is O(1).

# --------------------------------------------------------------
11 of 46: MillionGazillion 
  A web crawler need to keep track of visited websites.
  Note - sites may have multiple subdomains.

  www.abc.com/...  is same as abc.com/...
  We can save space on only storing one of those links

  We can make a set "visited"
  We can separate shared prefixes recursively
  even by one character - we can use a Trie (using dict of dict of ...):
      visited['g']['o']['o']['g']['l']['e']['.']['c']['o']['m']['*'] = True.
  The '*' at the end means 'this is the end of an entry'. 

  Complexity is ~O(26^N)

  Other solutions:
     ternary search tree
     bloom filter 

# --------------------------------------------------------------
12 of 46: Find in Ordered Set 
  Given an array of numbers in sorted order, how quickly could we
  check if a given number is present in the array?

Solution
  Because the list is sorted, we can use binary search 
  Complexity: O(lg N) time and O(1) space

# --------------------------------------------------------------
13 of 46: Find The Rotation Point In An Array 
  Given rotated array of words, find rotation point 
  Example:  arr = [mm nn oo pp qq aa bb cc dd] 
            in this case it is index of "aa"

  Solution - use binary search comparing with arr[0].
  Complexity - O(lg(n))

# --------------------------------------------------------------
14 of 46: Inflight Entertainment 
  Given - list of durations of movies.
  Write a function which returns True if there are two movies
  whose total runtime equals to flight length.
  Don't make your users watch the same movie twice.
  Optimize for runtime over memory.

Solution:
  keep a set seen_t so we can do:
      for t in durations:
          t2 = t_flight - t
          if t2 in seen_t:
              return True
          seen_t.add(t)

  Complexity O(N) for time and space

# --------------------------------------------------------------
15 of 46: Compute nth Fibonacci Number 
  Computer the nth Fibonacci number. 

    prev_prev = 0  # 0th fibonacci
    prev = 1       # 1st fibonacci

    for _ in xrange(n - 1):
        curr = prev + prev_prev
        prev_prev = prev
        prev = curr
    return curr

  Complexity O(N) for time and O(1) space

# --------------------------------------------------------------
16 of 46: The Cake Thief 
  You are stealing cakes.
  Each cake is described by a tuple (int,int) = (weight, value)
  Write a function
     max_duffel_bag_value(cake_tuples, max_w) 
  that takes two arguments:
     a list of cake type tuples and max_w = max_weight
  and returns the maximum monetary value the duffel bag can hold.

  Note: number of types is limited.
        supply of each type is unlimited.

  cake_tuples = [(7, 160), (3, 90), (2, 15)]
  max_w    = 20
  ret = max_duffel_bag_value(cake_tuples, max_w)

  effectiveness is (value per weight) ratio.
  So we want to try to fit as many most "effecitve" ones.
  And we try from the smallest bags (in total weight) - and 
  build the list max_values_at_capacities

    def max_duffel_bag_value(cake_tuples, max_w):
        max_vals_for_N = [0] * (max_w + 1)
        for curr_w in range(max_w + 1):
            curr_max_val = 0
            for w, v in cake_tuples:
                if w == 0 and v != 0:
                    return float('inf')
                if w <= curr_w:
                    max_val4cake = v + max_vals_for_N[curr_w - w]
                    curr_max_val = max(max_val4cake, curr_max_val)
            max_vals_for_N[curr_w] = curr_max_val
    
        return max_vals_for_N[max_w]

  O(n k) time, and O(k) space, 
  where "n" is the number of types, 
  and "k" is capacity of the bag

# --------------------------------------------------------------
17 of 46: JavaScript Scope 

There's something tricky going on with scope in this JavaScript.
Can you guess what will get logged to the console?

    var text = 'outside';
    function logIt(){
        console.log(text);
        var text = 'inside';
    };
    logIt();

Solution: it will print "undefined"
Explanation - Hoisting: the "var" declaration from outside
 (but NOT the assignment)
will be effectively put on top of function scope like this:

    var text = 'outside';
    function logIt(){
        var text;
        console.log(text);
        text = 'inside';
    };
    logIt();

# --------------------------------------------------------------
18 of 46: What's Wrong with This JavaScript? 
There's a tricky bug in this JavaScript. Can you find it? 

    <button id="btn-0">Button 1!</button>
    <button id="btn-1">Button 2!</button>
    <button id="btn-2">Button 3!</button>
    
    <script type="text/javascript">
        var prizes = ['A Unicorn!', 'A Hug!', 'Fresh Laundry!'];
        for (var btnNum = 0; btnNum < prizes.length; btnNum++) {
            // for each of our buttons, when the user clicks it...
            document.getElementById('btn-' + btnNum).onclick = function() {
                // tell her what she's won!
                alert(prizes[btnNum]);
            };
        }
    </script>


Problem: The user's prize is always undefined!
A function accesses a variable "btnNum" outside its scope.
When the value held by the variable changes, the function gets that new value. 
By the time the user starts pressing buttons, our loop will have 
already completed and btnNum will be 3, 
so each of our anonymous functions will get 3 for btnNum.
But "prizes" has three elements with indices 0,1,2.
Accessing a nonexistent index in an array returns undefined


Here is a fix using outer function which accepts the "btnNum":


    ...
            document.getElementById('btn-' + btnNum).onclick = function(frozenBtnNum){
                return function() {
                    // tell her what she's won!
                    alert(prizes[frozenBtnNum]);
                };
            }(btnNum);
    ....


# --------------------------------------------------------------
19 of 46: Implement A Queue With Two Stacks 
  Assume you already have a stack implementation.

Solution:
  Start putting stuff into stack1
  As soon as we get first "dequeue" request - move all from stack1 to stack2
  output from stack2
  input into stack1

  in:123  out:
  in:     out:321  ->1
  in:45   out:32   ->2,3
  in:456  out:
  in:     out:654  ->4
  etc.

# --------------------------------------------------------------
20 of 46: Largest Stack 
  You've implemented a Stack class, but you want to access the
  largest element in your stack from time to time. Write an
  augmented LargestStack class.

Solution:
  maintain maximums in a separate stack.

# --------------------------------------------------------------
21 of 46: The Stolen Breakfast Drone 
  Breakfast is delivered by drones, one drone has gone missing. 
  Write a function to figure out which one is missing.
  Given the list of IDs, which contains many duplicate integers 
  and one unique integer, find the unique integer.

Solution - use XOR:
   a^b = b^a
   a^(b^c) = (a^b)^c
   a^a == 0
   So if we have bunch of IDs where some are duplicated:
   a^b^c^d^e^a^b^c^d = (a^a)^(b^b)^(c^c)^(d^d)^e = 0^0^0^0^e = e

# --------------------------------------------------------------
22 of 46: Delete Node 
  Write a function to delete a node from a linked list. 
  Turns out you can do it in constant time!

Solution:
    a -> b -> c
  If we have "a", then we can do:
    a.next = a.next.next
    del a.next

  If we only given "b", we can copy "c" to "b":
    b.value = b.next.value
    b.next = b.next.text
    del b.next

  Complexity: O(1) for time and space

# --------------------------------------------------------------
23 of 46: Does This Linked List Have A Cycle? 

Solution: rabit and turtle.
  Let's make two variables, slow_runner and fast_runner. 
  slow_runner advances one node, while fast_runner advance two nodes.
  If there is no cycle, rabit will finish ahead of turtle.
  If there is a cycle, both will go in circles, rabit gaining 1 step
  at a time - and eventually catch up with turtle.

  Complexity : O(n) time and O(1) space 

# --------------------------------------------------------------
24 of 46: Reverse A Linked List  in-place.

Solution: in one pass from head to tail of our input list, 
  we point each node's next pointer to the previous item.

         prev -> curr -> curr.next
              <-      <-  

def reverse(head):
    curr = head
    prev = None
    next = None

    while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next

    return prev


# --------------------------------------------------------------
25
Kth to Last Node in a Singly-Linked List 
Find the kth to last node in a singly-linked list. We'll start
with a simple solution and move on to some clever tricks. keep
reading 


Solution 1:
  Walk 1st time to get the length of the list N.
  Walk 2nd time to (N-k)th node.
Solution 2:
  maintain a k-wide "stick" in one walk.
    while right_node.next:
        left_node  = left_node.next
        right_node = right_node.next


# --------------------------------------------------------------
26
Reverse String in Place 
Write a function to reverse a string in-place.
Solution: convert string to list, do swapping, then join


    def reverse(string):
        string_list = list(string)
    
        left_index  = 0
        right_index = len(string_list) - 1
        while left_index < right_index:
            # Swap characters
            string_list[left_index], string_list[right_index] = \
                string_list[right_index], string_list[left_index]
            # Move towards middle
            left_index  += 1
            right_index -= 1
    
        return ''.join(string_list)


Complexity: O(N) time, O(1) space


# --------------------------------------------------------------
27
Reverse Words 
Write a function to reverse the word order of a string
presented as a lsit of chars, in-place. 


Solution:
  step1: reverse all chars in the whole string
  step2: reverse each word in place


def rev_chars(arr, idx1, idx2):
    # Walk towards the middle, from both sides
    while idx1 < idx2:
        # Swap the left char and right char
        arr[idx1], arr[idx2] = arr[idx2], arr[idx1]
        idx1  += 1
        idx2 -= 1


def reverse_words(arr):
    # First we reverse all the chars in the entire message
    rev_chars(arr, 0, len(arr)-1)


    idx1 = 0


    for ii in range(len(arr) + 1):
        if (ii == len(arr)) or (arr[ii] == ' '):
            rev_chars(arr, idx1, ii - 1)
            idx1 = i + 1


Complexity: O(N) time, O(1) space


# --------------------------------------------------------------
28
Parenthesis Matching 
Write a function that finds the corresponding closing
parenthesis given the position of an opening parenthesis in a
string.


Solution - walk and count open/close parens.


    def get_closing_paren(sentence, opening_paren_index):
        open_nested_parens = 0
        position = opening_paren_index + 1
    
        while position <= len(sentence) - 1:
            char = sentence[position]
    
            if char == '(':
                open_nested_parens += 1
            elif char == ')':
                if open_nested_parens == 0:
                    return position
                else:
                    open_nested_parens -= 1
    
            position += 1
    
        raise Exception("No closing parenthesis :(")


Complexity: O(N) time, O(1) space


# --------------------------------------------------------------
29
Bracket Validator 
Write a super-simple parser of JavaScript code 
that can find unmatched brackets.


def is_valid(code):
    openers_to_closers = {
        '(' : ')',
        '{' : '}',
        '[' : ']'
    }


    openers = frozenset(openers_to_closers.keys())
    closers = frozenset(openers_to_closers.values())


    openers_stack = []


    for char in code:
        if char in openers:
            openers_stack.append(char)
        elif char in closers:
            if not openers_stack:
                return False
            else:
                last_unclosed_opener = openers_stack.pop()


                # if this closer doesn't correspond to the most recently
                # seen unclosed opener, short-circuit, returning false
                if not openers_to_closers[last_unclosed_opener] == char:
                    return False


    return openers_stack == []


Complexity
O(n) time, and O(n) space 


# --------------------------------------------------------------
30
Permutation Palindrome 
Write an efficient function that checks whether some permutation
of a string is a palindrome (example: civic)


Solution: check that we have no more than 1 character appearing 
odd number of times.


 in q_fb.txt


# --------------------------------------------------------------
31
Recursive String Permutations 
Write a recursive function generating all permutations of a string.


Solution: 
    If we're making all permutations for "cat," we take all
    permutations for "ca" and then put "t" in each possible
    position in each of those permutations.
    We use this approach recursively:


    def get_permutations(ss):
        if len(string) <= 1:
            return set([ss])
        all_except_last = ss[:-1]
        last_char = ss[-1]
    
        # Recursive call: get all possible permutations 
        # for all chars except last
        perm_all_except_last = get_permutations(all_except_last)
    
        # Put the last char in all possible positions 
        # for each of the above permutations
        permutations = set()
        for perm in perm_all_except_last:
            for idx in range(len(all_except_last) + 1):
                permutation = (perm[:idx]+last_char+perm[idx:])
                permutations.add(permutation)
    
        return permutations


# --------------------------------------------------------------
32
Top Scores 
Efficiently sort numbers in an array, where each number is below
a certain maximum.


Solution - use "counting sort"


    def sort_scores(unsorted_scores, highest_possible_score):
    
        # list of 0s at indices 0..highest_possible_score
        score_counts = [0] * (highest_possible_score+1)
    
        # populate score_counts
        for score in unsorted_scores:
            score_counts[score] += 1
    
        # populate the final sorted list
        sorted_scores = []
    
        # for each item in score_counts (from top scores down)
        for score in range(len(score_counts) - 1, -1, -1):
            count = score_counts[score]
            for _ in range(count):
                sorted_scores.append(score)
    
        return sorted_scores


Complexity O(n) time and O(n) space


# --------------------------------------------------------------
33
Which Appears Twice 
We have array of (N+1) numbers with values 1..N. 
We know that only one number is duplicated.
Find it.


Solution:  sum(all_numbers) - N*(N+1)/2


# --------------------------------------------------------------
34
Word Cloud Data 
You're building a word cloud. Write a function to figure out how
many times each word appears so we know how big to make each
word in the cloud.


 in q_google.txt


# --------------------------------------------------------------
35
In-Place Shuffle 
Do an in-place shuffle on an array of numbers. 
The shuffle must be "uniform," meaning each item in the original
list must have the same probability of ending up in each spot 
in the final list.
Assume that you have a function get_random(floor, ceiling) 
for getting a random integer that is >= floor and <= ceiling.


Solution: semi-famous algorithm known as the Fisher-Yates 
    shuffle (sometimes called the Knuth shuffle).


    import random
    
    def get_random(floor, ceiling):
        return random.randrange(floor, ceiling + 1)
    
    def shuffle(lst):
        if len(lst) <= 1:
            return lst
        nn = len(lst) - 1
        for ii in xrange(0, nn):
            rr = get_random(ii, nn)
            if rr != ii:
                lst[ii], lst[rr] = lst[rr], lst[ii]




Complexity O(n) time and O(1) space


# --------------------------------------------------------------
36
Single Riffle Shuffle 
Write a function to tell us if a deck of cards is a single
riffle of two other halves.


 in q_fb.txt


# --------------------------------------------------------------
37
Simulate 5-sided die 
Given a 7-sided die, make a 5-sided die.


  def rand5():
    result = 7  # arbitrarily large
    while result > 5:
        result = rand7() // re-roll
    return result


# --------------------------------------------------------------
38
Simulate 7-sided die 
Given a 5-sided die, make a 7-sided die.


    def rand7():
        while True:
            roll1 = rand5()
            roll2 = rand5()
            outcome_number = (roll1-1) * 5 + (roll2-1) + 1
            if outcome_number > 21:
                continue
            return outcome_number % 7 + 1


 in q_google.txt


# --------------------------------------------------------------
39
Two Egg Problem 
A building has 100 floors. Figure out the highest floor an egg
can be dropped from without breaking.


 in q_google.txt


# --------------------------------------------------------------
40
Find Repeat, Space Edition 
Find Duplicate, Space Edition
Figure out which number is repeated. But here's the catch:
optimize for space.


 in q_google.txt


# --------------------------------------------------------------
41
Find Repeat, Space Edition BEAST MODE 
Fine Duplicate, Space Edition BEAST MODE
Figure out which number is repeated. But here's the catch: do it
in linear time and constant space!


 in q_google.txt


# --------------------------------------------------------------
42
Find Duplicate Files 
Your friend copied a bunch of your files and put them in random
places around your hard drive. Write a function to undo the
damage.


 in q_google.txt


# --------------------------------------------------------------
43
Merge Sorted Arrays 
Write a function for consolidating cookie orders and taking over
the world.


 - see in q_fb.txt


# --------------------------------------------------------------
44
URL Shortener 
Design a URL shortener, like bit.ly


XXXXXXXXXXXXXXXXXXXX


# --------------------------------------------------------------
45
Graph Coloring 
Color the nodes in a graph so adjacent nodes always have
different colors.


XXXXXXXXXXXXXXXXXXXX


# --------------------------------------------------------------
46
MeshMessage 
You wrote a trendy new messaging app, MeshMessage, to get around
flaky cell phone coverage. But messages are taking too long to
send...


Given information about active users on the network, find the 
shortest route for a message from one user (the sender) to another
(the recipient). Return a list of users that make up this route.


    from collections import deque
    
    def reconstruct_path(previous_nodes, start_node, end_node):
    
        reversed_shortest_path = []
    
        # start from the end of the path and work backwards
        current_node = end_node
    
        while current_node:
            reversed_shortest_path.append(current_node)
            current_node = previous_nodes[current_node]
    
        # reverse our path to get the right order
        reversed_shortest_path.reverse()  # flip it around, in place
        return reversed_shortest_path  # no longer reversed
    
    def bfs_get_path(graph, start_node, end_node):
    
        if start_node not in graph:
            raise Exception('Start node not in graph')
        if end_node not in graph:
            raise Exception('End node not in graph')
    
        nodes_to_visit = deque()
        nodes_to_visit.append(start_node)
    
        # keep track of how we got to each node
        # we'll use this to reconstruct the shortest path at the end
        # we'll ALSO use this to keep track of which nodes we've
        # already visited
        how_we_reached_nodes = {start_node: None}
    
        while len(nodes_to_visit) > 0:
            current_node = nodes_to_visit.popleft()
    
            # stop when we reach the end node
            if current_node == end_node:
                return reconstruct_path(how_we_reached_nodes, start_node, end_node)
    
            for neighbor in graph[current_node]:
                if neighbor not in how_we_reached_nodes:
                    nodes_to_visit.append(neighbor)
                    how_we_reached_nodes[neighbor] = current_node
    
        # if we get here, then we never found the end node
        # so there's NO path from start_node to end_node
        return None


Complexity: O(M+N) time, O(N)space


XXXXXXXXXXXXXXXXXXXX


# --------------------------------------------------------------