passing technical IT interview

Two types of interviews:
 Type 1. technical screening
 Type 2. conversation with decision maker

In both cases:
  - project excitement about the company and about the topics.
Excitement, kindness, good karma mean more than technicalities.
  - Consider it as not an exam, but rather as a work situation 
    where you and your interviewer are solving real problem together
  - you may not know the answer - but you are evaluated how 
    you are communicating your thoughts and collaborating.
  so:
  - when given a problem - listen, repeat it 
    and ask questions to make sure you understand it
    make a simple example
  - aks if you can make certain assumptions, etc.
  - be really curious about finding a really good solution
  - verbalize your thought process
  - first code the very simple not-optimized solution
    (brute-force) and calculate it's time and space complexity
    (for example, O(N^2) time, ... space)
  - then discuss possible methods to optimize the solution
    formulate steps as comments and modules, fill in code,
    consider edge cases (zeros, nulls, beginning, end, etc.)
    test the code (walk through)
  - don't be nervous if you don't know specific programming syntax.
    Most important is to get the logic, the thinking

Below some short notes about data structures and algorithms.
You need to understand them.
Then do lots of practice problems to learn how to use them.
There are many sites with questions and answers, books, youtube videos, etc.

=======================================
array, list, tuple, sequence, index, slice
=======================================
stack (FILO = First In Last Out)
queue (FIFO = First In First Out)
priority queue
    (ticket, priority)
  [(4,5),(3,5),(2,5)(1,5)]
  [(4,5),(2,5)(1,5),(3,1)]
=======================================
set (unique elements)
hash (hashmap, dict)
Example of hashing function:
   # ------------------------------
   hash = 0
   for char in key_str:
     hash = hash*33 + ord(char)
   idx = hash / num_buckets
   # ------------------------------

=======================================
Bloom filter
  Imagine that we have a huge lookup table (~millions of words)
  and we testing if a word is in this table or not. 
  We may use a huge hash on disk, causing big disk I/O.

  Bloom filter uses a small compact bitmap instead of big hash.
  This allows to reject most negatives - while allowing very few false-positives.
  The negatives are definitely negatives, but positives 
  are "maybe" positives.

  An empty Bloom filter is a bit array of m bits, all set to 0.
  There must also be k different hash functions defined, 
  each of which maps an element to one of m bits (sets it to 1).
  So if we use k hash functions - we can get up to "k" bits set.
  Example: m=30, k=10
  To query for an element (test whether it is in the set), 
  feed it to each of the k hash functions to get k array positions. 
  If any of the bits at these positions is 0, the element is not in the set.
  If all are 1, then it may be positive - or false-positive.
  resulting in a false positive. 

  If map is big enough, the patterns will be sparse, 
  and probability of false-positives very low.
  - https://hur.st/bloomfilter
=======================================
BST (Binary Search Tree)
  rebalancing BST (rotations)
  height of the tree h = lg2(N)..N, search time ~h
=======================================
Trie - prefix tree, good for words/characters
=======================================
Binary Heaps (MaxHeap and MinHeap)
    data structure which looks like binary tree
    where each parent is >= (or <= for min-heap) than values of children
Binary heaps are a common way of implementing priority queues. 
Given an array we can "heapify" it in place by swapping elements.
0 - top (root) element
1,2 - next layer (left and right children)
3,4,5,6 - next layer
etc.
last parent's idx = floor(N/2) - 1

Time complexity:
    building heap - O(N)
    push (at bottom) and adjust - O(lg(N))
    pop (from top) and adjust   - O(lg(N))
    heap sort - O(N*log(N))
https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity
=======================================
linked list
  head of the list
  going through the list
  finding cycle in the linked list by using turtle and rabbit (slow and fast runners)
=======================================
sorting:
  in-place
  stable sort (preserves order of duplicates)
=== bubble sort   O(n^2)
  (go through whole list swapping neighbors until nothing to swap)
=== selection sort O(n^2)
  divide list into two portions: left sorted, right not sorted yet
  on each step: select min value from right - append to left
=== insert sort   O(n^2)
  (take one element, insert it in its place on the left, repeat)
=== merge sort  O(n log n)
  binary division, sort small pieces, then merge them layer by layer 
=== heap sort O(n log n)
  make MinHeap in the array, 
  take min value, out of the heap, fix the heap, repeat.
=== quick sort O(n log n) - or O(n^2) in worst case
  pick an element in the middle called a pivot
  move to the right of it all elements which are > pivot
  move to the left of it all elements which are < pivot
  Now recursively apply the same process to left and right subarrays.
=== tim sort O(n) - O(n log n)
   used in python, combination of merge and insertion sort algs.
   takes advantage of runs of consecutive ordered elements
=======================================
topological sort
   schedule a sequence of jobs based on their dependencies. 
   Example: make files for compilation, etc.
   Dependencies may be represented by a graph:
      jobs are points (vertices of a graph)
      x ---> y  means that we need to calculate "x" before "y"
      (x needed for calculating "y")
   Kahn algorithm:
     jobs=[1,2,3,4, 5, 6]
     dependencies = [(1,3), (3,2), (3,4), (5,6)]  
     # (m, n) where n is a dependency of m
     1. for each job calculate number of dependencies NoD
     2. find jobs with no dependencies - put them into a queue.
     3. process the queue one by one like this:
       take queue element, append to the output
       take its dependencies, reduce their NoD by one
       if NoD for any of them becomes zero, add those to the queue
Complexity: O(Njobs + Ndependencies)
=======================================
Searches: 
  Binary search
  DFS (Depth-First Search) - recursion 
  BFS (Breadth-First Search) - queue, level by level
=======================================
Note: Recursion can always be rewritten as iteration

factorial_recursive(n):
    if n<=1:
        return 1
    else:
        return n * factorial_recursive(n-1)

factorial_iterative(n):
    ff = 1
    for ii in range(1,n+1):
        ff *= ii
    return ff

=======================================
Algorithm complexity (time and space):
Big "O" notation
  O(1), O(N) , O(N^2) , O(N*log(N)), O(p*k), etc.
==================================
bottoms-up and top-down algorithms
divide-and-conquer
greediness
==================================
declarative vs imperative procedural programming
==================================
functional programming
  use pure functions 
  avoid side effects (global variables, etc.)
==================================
dynamic programming = memoization
    (caching results to reuse them instead of recalculating)
    common to use a dictionary for that
==================================
Bit manipulation
  binary positive, negative, addition, shifting, masks
        & – Bitwise AND
        | – Bitwise OR
        ~ – Bitwise NOT
        ^ – XOR
        << – Left Shift
        >> – Right Shift
==================================
Some tricks and examples:
    merging two sorted lists
    finding largest word
    finding duplicates (use hash)
    func(N) as func of smaller numbers
    calculate Fibonacci numbers
    coin-change (using memoization)
    recursive staircase (1,2,3 steps - how many ways?)
    shortest reach path (using BFSearch)
    balanced parentheses (using stack)
    queue with 2 stacks
    keep contacts in a Trie
    mirroring BST
    finding the 2nd largest value in BST (binary tree)
    (or verifying that the tree is correct)
==================================

